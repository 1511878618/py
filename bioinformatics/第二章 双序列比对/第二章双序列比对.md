





三个重要概念的辨析

- 同源（homologous）：两个序列享有**一个共同的进化上的祖先**，则两个序列是同源的。同源是个定性的概念，**只能说同源或不同源，不能说70%同源**。基因组分析中，同源性是根据数据库搜索和序列比对确定的，高度相似则可能同源。 同源又分为**垂直同源（ortholog），是种系形成过程中起源于一个共同祖先的不同种系中的DNA或蛋白质序列**；而水平同源（paralog），是由序列复制事件产生的，**是存在与一个物种间**。
- 相似（similarity）：**相似是定量的概念，基于对序列中字符的精准比较**。是一个与 两个序列对应位置上相同字符的个数相关的函数。对与相似性的描述，一般是采用一种记分规则（打分矩阵）来计算两个序列**相似性得分**的总分值。
- 相同（identity）：定量的概念



由相似的概念中提出了描述两个序列之间的关系的一种方式——相似性得分。但是由于两条序列往往长度不一样，不能简单的根据对应位置的字符来按照记分规则进行计算相似性得分。

> 这种基于打分规则来计算相似性得分的比对方式称为双序列比对，但由于序列长度的差异，还需要引入空格与动态规划算法来计算最优的相似性得分。

因而进行比对还需要引入一个概念——**空格**

那么什么是空格？

- 空格（gap）：序列比对时，**加入到一条序列中的空格，使得两条条序列可以充分的对齐**。常见的突变方式替换、删除、插入。后两者都可以看做其中一条序列插入了空格而产生的现象。但是引起一次多字符插入和删除的概率是大于同数量的多次单字符插入和删除的概率。

那么知道空格的作用与生物学意义后。便可以正式介绍双序列比对了

#### 双序列比对

双序列分为

- 局部比对（local ）：目的是**寻找一条小序列在另外一条大序列中的相似性，或者是否有同源的子序列**

- 全局比对（）：目的是对**两条长度差异不大的序列计算相似性得分，推断是否同源**

双序列比对的核心是 如何计算相似性得分

对于序列中的插入和删除突变 可以用插入空格来处理，使得原本对应得字符对齐。

但是对于序列中得替换突变，则**需要考虑不同替换得意义**，对于不同替换如何记分（实际上是罚分）又是计算相似性得分得关键。



###### 首先先介绍一种直观查看两条序列的配对情况的方法——对角线作图

把两条序列分别放在X和Y轴，有序的从左到右，从下到上的进行字符的比较，如果两个字符相同则在对应的坐标打上一个点。便可以得到对角线作图的结果。

**对于序列中存在的相同子序列，会在结果中出现一条过原点的对角线**

**对于两条互为相反序列的子序列则会以反对角线的形式呈现**

![image-20200507092821669](https://file.upyun.biopy.cn/bed/20200507092824.png)





##### 替换积分矩阵

###### DNA常用的打分矩阵

- 等价矩阵（unitary matrix）：相同核苷酸的匹配得分为1，不同的为0。不常用
- **转换-颠换矩阵**（transition-transversion matrix）：由于DNA发生转换的频率比颠换高。配对得分为1，转换得分为-1，颠换得分为-5
- **BLAST矩阵**（）：基于大量实际比对得出的矩阵。 配对得分为+5，否则为-4.目前是最流行的打分矩阵

下面是上述三个打分矩阵

![IMG_0171](https://file.upyun.biopy.cn/bed/20200507093148.PNG)

###### 蛋白质序列列比对的打分矩阵

- 等价矩阵：同DNA一样
- **遗传密码矩阵（genetic code matrix，GCM）**：**通过计算一个氨基酸转变成另一个氨基酸所需的密码子变化的数目而得到，矩阵对应的元素即对应的转变代价。** 如：变化一个碱基就可以使得这个编码氨基酸的密码子变成编码另外的某个氨基酸，那么替换代价为1。下表为打分矩阵，其中X代表20中标准氨基酸以外的任何氨基酸。 **很少用于相似性程度比较低的蛋白质序列比对**，多用于绘制进化树与计算进化距离。![image-20200507093750944](https://file.upyun.biopy.cn/bed/20200507093753.png)

- **疏水性矩阵（hydrophobic matrix）**：**鉴于在某些蛋白质中，一些氨基酸可以很容易的相互取代而不改变它们的生理生化性质**。因而可以根据20种氨基酸的侧链基团的疏水性的不同以及氨基酸替换前后理化性质的变化大小，以氨基酸的疏水性为标准制定的疏水性矩阵。**偏重于蛋白质功能方面的序列比对![IMG_0173](https://file.upyun.biopy.cn/bed/20200507095822.PNG)**
- PAM矩阵（point accepted matrix，PAM）：**采用氨基酸的实际替换率作为打分。基于氨基酸进化的点突变模型得到每一对氨基酸的得分。 PAM是目前最常用的打分矩阵**。由于氨基酸进化的点突变模型（用全局比对）不同而得到的PAM矩阵可能会存在不同。PAM-X，X表示的每百个氨基酸平均发生X个突变的量值。PAM-X的得到可以由PAM-1自乘X次获得。但是别忘了一些氨基酸位置可以经历多次突变，甚至可能会变回原来的氨基酸。使用时注意：**序列相似度越高使用X越小得矩阵；序列相似度越低使用X越大得矩阵。因为相似度越高，说明进化上越近，突变得概率就越低**

> PAM制作步骤：
>
> 1. 构建序列相似（大于85%）的比对
> 2. 计算氨基酸$j$的相对突变率$m_j$ （$j$被其他氨基酸替换的次数）
> 3. 针对每个氨基酸对$i$和$j$，计算$j$被$i$替换的次数
> 4. 替换次数除以相对突变率（$m_j$）
> 5. 利用每个氨基酸出现的频度对$j$进行标准化

​	![image-20200507104438830](https://file.upyun.biopy.cn/bed/20200507104441.png)

- BLOSUM矩阵（block subsitution matrix，BLOSUM）：统计相似蛋白质序列的替换率得到的，但是使用的是**蛋白质序列块（短序列）比对推导出来的**。基本数据来源于BLOCKS数据库，包括局部多重比对，没有使用进化模型。 BLOSUM也有不同的编号，编号指序列可能相同的最高水平。如BLOSUM-62指具有62%相同比例的序列被组合统计后形成的矩阵。**一个问题，他们最开始比对用的是什么打分矩阵？**。使用时 应当注意：**比对高度相似的序列用较高值得BLOSUM矩阵；比对低相似度得用较低得BLOSUM矩阵**



有了打分矩阵，就可以进行双序列比对啦。

##### 双序列比对原理

生信中，对各种生物大分子得序列进行分析是非常基本得工作。序列得测定和拼接、RNA和蛋白质得结构功能预测、种系树得构建等都需要对生物分子序列相似性得比较。



而序列相似性比对在发现生物序列的有关功能、结构和进化的信息方面具有非常重要的意义。主要思想是：**运用特定的算法找出两个或多个序列之间产生最大相似性得分的空格插入和序列排列方案**



序列比对是解决序列装配、进化树重构与分析基因功能等众多问题的第一步。如何进行序列比对，相关的算法很多。为了找出最优的比对，多数采用了的**动态规划算法**。根据比对的序列数量的不同，又分为双序列比对和多序列比对。二者本质上没有区别。



根据上面的讲解。比对的关键除了打分矩阵外，便是找到一个产生**最大相似得分的排列方式和空格插入方式**

空格插入是什么刚刚说过了。

那么什么是**排列方式呢**？

闲言少述，直接进入正题。以下两条序列进行全局比对为例，Needleman-Wunsch算法的具体步骤如下：

\>sequence1

GCATGCU

\>sequence2

GATTACA

1. 初始化矩阵

首先建立一个空的矩阵，矩阵上的行名为sequence1的碱基，矩阵的列名为sequence2的碱基。因为需要初始值，所有数据区第一行和第一列依次为-1, -2, -3, -4...这组递减数列，相连两项之间的差值为gap罚分。

   这里为了方便起见，采用最一般的罚分，即match得1分，mismatch和gap罚1分（即得-1分，以下叙述均用得分表示，若为罚分则得分为负）。

**Needleman-Wunsch算法在开始引入了两个gap在序列开头**，作为矩阵计算的开始。

2. 计算矩阵

之后根据这样一个移动打分规则：

$F(i,j)$ 表示第一个Seq的第$i$个字符对应的列与第$j$个字符对应的行。

![Snipaste_2020-05-07_19-16-55](https://file.upyun.biopy.cn/bed/20200507191701.png)



$F(i-1,j-1)+s(x_i,y_i)$ 表示的是以$i,j$的左上角为起始往右下角走，过程分为$s(x_i,y_i)$。其中$i,j$对应的碱基相同

$F(i-1,j)+d$**表示的是$y_i$与一个空位匹配表现出来是一个从上到下的箭头**

$F(i,j-1)+d$ **表示的是$x_i$与一个空位匹配。表现出来是一个从左向右的箭头**



![Snipaste_2020-05-07_19-21-22](https://file.upyun.biopy.cn/bed/20200507192129.png)

矩阵计算的规则如上。



![Snipaste_2020-05-07_19-25-42](https://file.upyun.biopy.cn/bed/20200507192554.png)

通过使用上述规则计算可以得

![Snipaste_2020-05-07_19-31-15](https://file.upyun.biopy.cn/bed/20200507193138.png)



3.回溯获得最佳比对结果



沿右下角向左上角回溯，每个位点依然有三个位置，左上，左边和上边，如果**最大值出现在上面，则横向这条序列引入一个gap ("-")**，纵向这条序列取该处碱基；如果**最大值出现在左边，则纵向这条序列引入一个gap ("-")**，横向这条序列取该处碱基; **如果最大值出现在左上角，则不引入gap，纵向和横向均取该处碱基**。这样获取到两段序列，再反转过来（因为序列是从后往前回溯的）即为最终结果。

![Snipaste_2020-05-07_19-36-07](https://file.upyun.biopy.cn/bed/20200507193617.png)

即：          

GCAT-GCU

G-ATTACA

接下来 使用python 代码来实现这一过程。 

直接使用Bio包来实现比对

``` python
from Bio import pairwise2
from Bio.Seq import Seq
seq1 =Seq('GCATGCU')
seq2 = Seq('GATTACA')
aliments = pairwise2.align.globalms(seq1,seq2,1,-1,-1,-1)
for i in aliments:
    print(pairwise2.format_alignment(*i))
```

``` python 
GCATG-CU
| ||. |.
G-ATTACA
  Score=0

GCAT-GCU
| || .|.
G-ATTACA
  Score=0

GCA-TGCU
| | |.|.
G-ATTACA
  Score=0
```

python代码实现见文件。



